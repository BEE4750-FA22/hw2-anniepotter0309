---
title: "BEE 4750/5750 Homework 2"
author: "Anne Potter (ap674)"
date: `j import Dates; Dates.Date(Dates.now())`
weave_options:
    term: true
    results: tex
    cache: off
---

<!-- This setups the environment and installs packages, but doesn't appear in the generated document -->
<!-- You shouldn't need to modify this -->
```julia; echo = false; results = "hidden"
using Pkg
Pkg.activate(".")
Pkg.instantiate()
```

# Problem 1

## Problem 1.1
```julia
using Plots
# Given variable definitions
C_s  = 10;   #mg/L
U    = 6;    #km/d
k_a  = 0.55; #d^-1
k_c  = 0.35; #d^-1
k_n  = 0.25; #d^-1
Q_r  = 100000000; #L/day
Q_1  = 10000000;  #L/day
Q_2  = 15000000;  #L/day
C_0r = 7.5;  #mg/L
C_01 = 5;    #mg/L
C_02 = 5;    #mg/L
B_0r = 5;    #mg/L
B_01 = 50;   #mg/L
B_02 = 45;   #mg/L
N_0r = 5;    #mg/L
N_01 = 35;   #mg/L
N_02 = 35;   #mg/L


function do_calc(k_a, k_c, k_n, x, U, C_s, C_0, B_0, N_0)
  a_1 = exp(-k_a*x/U)
  a_2 = (k_c / (k_a - k_c)) * (exp(-k_c*x/U) - exp(-k_a*x/U))
  a_3 = (k_n / (k_a - k_n)) * (exp(-k_n*x/U) - exp(-k_a*x/U))
  B_x = B_0 * (exp(-k_c*x/U))
  N_x = N_0 * (exp(-k_n*x/U))
  C_x = C_s*(1-a_1) + C_0*a_1 - B_0*a_2 - N_0*a_3
  return C_x, B_x, N_x
end
 
#concentrations at entry of source 1
c_0 = (Q_r*C_0r + Q_1*C_01) / (Q_r+Q_1)  
b_0 = (Q_r*B_0r + Q_1*B_01) / (Q_r+Q_1)
n_0 = (Q_r*N_0r + Q_1*N_01) / (Q_r+Q_1)
 
# allocate space for data storage
global C  = zeros(51);
global B  = zeros(51);
global N  = zeros(51);

# concentration of CBOD, NBOD and DO after source 1
for dist in 0:15
  C[dist+1], B[dist+1], N[dist+1] = do_calc(k_a, k_c, k_n, dist, U, C_s, c_0, b_0, n_0)
end
 
#concentrations at entry of source 2
c_1 = ((Q_r+Q_1)*C[16] + Q_2*C_02) / (Q_r+Q_1+Q_2)  
b_1 = ((Q_r+Q_1)*B[16] + Q_2*B_02) / (Q_r+Q_1+Q_2)
n_1 = ((Q_r+Q_1)*N[16] + Q_2*N_02) / (Q_r+Q_1+Q_2)
 
# concentration of CBOD, NBOD and DO after source 2
for dist in 0:35
  C[dist+16], B[dist+16], N[dist+16] = do_calc(k_a, k_c, k_n, dist, U, C_s, c_1, b_1, n_1)
end
 
# create vector for x axis of plot
distance  = range(0, 50, length = 51);
 
# create plot of DO
plot(distance, C, title = "Concentration of DO vs distance");
xlabel!("Distance [km]");
ylabel!("Concentration of DO [mg/L]")
```

## Problem 1.2
```julia
# minimum point of curve after second input ~= 30
let x = 5 
  while C[x] < 6
    x += 1
  end
  println(x)
  println(C[x])
end
```
DO recovers to 6 mg/L at 42 km after the first source, or 27 km after the second source.

## Problem 1.3
```julia
function treated_conc(e, N_0, B_0, C_0)
  b_new = (1-e) * B_0
  n_new = (1-e) * N_0
  c_new = (1-e) * C_0
  return c_new, b_new, n_new
end

e = range(0, 1, 101)
C_t = ones(101) * 100

# find concentrations in river just before addition of source 2
c_riv, b_riv, n_riv = do_calc(k_a, k_c, k_n, 15, U, C_s, c_0, b_0, n_0)

for i in 1:101
  # concentration in treated source 2
  c_2, b_2, n_2 = treated_conc(e[i], N_02, B_02, C_02)

  # find concentration in river after addition
  c_r2 = ((Q_1+Q_r)*c_riv + Q_2*c_2) / (Q_1+Q_2+Q_r)
  b_r2 = ((Q_1+Q_r)*b_riv + Q_2*b_2) / (Q_1+Q_2+Q_r)
  n_r2 = ((Q_1+Q_r)*n_riv + Q_2*n_2) / (Q_1+Q_2+Q_r)

  # find minimum DO after addition of source 2
  for dist in 1:36

    # concentration in river at addition of source 2
    C_t2, B_t2, N_t2 = do_calc(k_a, k_c, k_n, dist, U, C_s, c_r2, b_r2, n_r2)

    # update C_t if new min is found for treatment level
    if C_t2 < C_t[i]
      println(C_t[i])
      C_t[i] = C_t2
    end
  end
end

# find and print minimum treatment that meets standard
let j = 1
  while C_t[j] < 4
    j += 1
  end
  println(e[j])
  println(C_t[j])
end
```
The minimum treatment level for waste stream 2 that will ensure the dissolved 
oxygen concentration never drops below 4 mg/L is 0.14.

## Problem 1.4
```julia
e = range(0, 1, length = 101);
C_treat = ones(101) * 100;

# iterate over the treatment efficiencies
for i in 1:101
  # initial concentrations of source 1, with treatment
  C_11, B_11, N_11 = treated_conc(e[i], N_01, B_01, C_01)

  # concentrations in river after addition of treated source 1
  c_0 = (Q_r*C_0r + Q_1*C_11) / (Q_r+Q_1)  
  b_0 = (Q_r*B_0r + Q_1*B_11) / (Q_r+Q_1)
  n_0 = (Q_r*N_0r + Q_1*N_11) / (Q_r+Q_1)

  # concentrations of river at input of source 2, treated
  C_12, B_12, N_12 = do_calc(k_a, k_c, k_n, 15, U, C_s, c_0, b_0, n_0)

  # initial concentration of source 2, with treatment
  C_22, B_22, N_22 = treated_conc(e[i], N_02, B_02, C_02)

  # concentrations of river after addition of treated source 2
  c_2tr = ((Q_r+Q_1)*C_12 + Q_2*C_22) / (Q_r+Q_1+Q_2) 
  b_2tr = ((Q_r+Q_1)*B_12 + Q_2*B_22) / (Q_r+Q_1+Q_2)
  n_2tr = ((Q_r+Q_1)*N_12 + Q_2*N_22) / (Q_r+Q_1+Q_2)

  # find minimum DO level for each treatment
  for dist in 1:36
    C_tr, B_tr, N_tr = do_calc(k_a, k_c, k_n, dist, U, C_s, c_2tr, b_2tr, n_2tr)
    if C_tr < C_treat[i]
      C_treat[i] = C_tr
    end
  end
end

# print minimum treatment necessary
let i = 1
  while C_treat[i] < 4
      i += 1
  end
  println(e[i])
  println(C_treat[i])
end
```
If both waste streams are treated equally, the minimum level of treatment of the 
two sources to ensure the dissolved oxygen concentration never drops below 4 mg/L
is 0.08.

## Problem 1.5

## Problem 1.6


## Problem 1.7

```julia; echo=false
# This block will not show up in compiled output.

using Distributions
using PDMats

# This function samples n correlated variates distributed over 
# Uniform([a[1], a[2]]) and Uniform([b[1], b[2]]) with correlation coefficient
# corr_coef.
function sample_correlated_uniform(n, a, b, corr_coef=0.7)
  mvnorm = MvNormal([0, 0], PDMat([1 corr_coef; corr_coef 1])) # set up a multivariate normal with each marginal variance of 1 and the right correlation
  norm_samples = rand(mvnorm, n)' # sample from the multivariate normal, the marginal distributions are a standard normal
  unif_samples = cdf.(Normal(0, 1), norm_samples) # convert samples to a uniform distribution using the pdf of a standard Normal
  samples = (unif_samples .* [a[2] - a[1] b[2] - b[1]]) .+ [a[1] b[1]]
  return samples
end
```

## Problem 1.8

```

# References
